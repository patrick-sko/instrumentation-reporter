/*
 * Copyright 2020 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google;

import static com.google.ProfilingReport.createProfilingReport;

import com.google.ProfilingReport.ProfilingData;
import com.google.common.base.Strings;
import com.google.common.io.CharStreams;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;


/**
 * This class will read a file that contains the instrumentation mapping generated by the compiler
 * production instrumentation pass, and also a list of other files which are the reports sent by the
 * instrumented production code. It will then take these inputs and generate a single JSON which
 * provides a detailed breakdown of each instrumentation point.
 */
public class ProductionInstrumentationReporter {

  @Option(
      name = "--mapping_file",
      usage = "The file name of the mapping generated by the production instrumentation pass.")
  private String instrumentationMappingLocation = "";

  @Option(
      name = "--reports_directory",
      usage = "The folder/directory which contains all the reports created by the instrumented"
          + " production code.")
  private String instrumentationReportsDirectory = "";

  @Option(
      name = "--result_output",
      usage = "Use this flag to provide the name of the final report that will be generated by"
          + "this reporter.")
  private String finalResultOutput = "";


  public static void main(String[] args) {
    try {
      new ProductionInstrumentationReporter().doMain(args);
    } catch (IOException e) {
      System.err.println(e.getMessage());
      System.err.println(e.getStackTrace());
    }
  }

  /**
   * This function reads a file at the given filePath and converts the contents into a string.
   */
  public static String readFile(String filePath) throws IOException {
    return CharStreams.toString(new FileReader(filePath));
  }

  /**
   * Reads all files found in folder and converts the contents of each file to a Map<String,
   * ProfilingData> data structure where it is a mapping of the unique param value to the encoded
   * values. The folder contains all the reports sent by the instrumented production code.
   */
  private List<Map<String, ProfilingData>> getAllExecutionResults(File folder)
      throws IOException {
    List<Map<String, ProfilingData>> result = new ArrayList<>();

    for (final File fileEntry : folder.listFiles()) {
      String executionResult = readFile(fileEntry.getAbsolutePath());
      Type type = new TypeToken<Map<String, ProfilingData>>() {
      }.getType();
      Map<String, ProfilingData> executedInstrumentationData = new Gson()
          .fromJson(executionResult, type);

      result.add(executedInstrumentationData);

    }

    return result;
  }

  /**
   * Creates a file with the given fileName (including extension) with the contents of the file
   * being provided by fileContents.
   */
  private void createFile(String fileName, String fileContents) throws IOException {

    File fold = new File(fileName);
    fold.delete();
    File myObj = new File(fileName);
    myObj.createNewFile();

    FileWriter myWriter = new FileWriter(fileName);
    myWriter.write(fileContents);
    myWriter.close();
  }

  public void doMain(String[] args) throws IOException {

    parseCmdLineArguments(args);

    InstrumentationMapping instrumentationMapping = InstrumentationMapping
        .parse(instrumentationMappingLocation);

    File folder = new File(instrumentationReportsDirectory);

    List<Map<String, ProfilingData>> listOfExecutionResults = getAllExecutionResults(folder);

    ProfilingReport profilingReport = createProfilingReport(
        instrumentationMapping, listOfExecutionResults);

    Gson gson = new GsonBuilder().setPrettyPrinting().create();
    createFile(finalResultOutput, gson.toJson(profilingReport));

  }

  private void parseCmdLineArguments(String[] args) {
    CmdLineParser parser = new CmdLineParser(this);
    parser.setUsageWidth(80);
    try {
      parser.parseArgument(args);
    } catch (CmdLineException e) {
      System.err.println(e.getMessage());
      return;
    }

    if (Strings.isNullOrEmpty(instrumentationMappingLocation)) {
      throw new IllegalArgumentException("Expected flag, --mapping_file to be set.");
    }

    if (Strings.isNullOrEmpty(instrumentationReportsDirectory)) {
      throw new IllegalArgumentException("Expected flag, --reports_directory to be set.");
    }

    if (Strings.isNullOrEmpty(finalResultOutput)) {
      throw new IllegalArgumentException("Expected flag, --result_output to be set.");
    }
  }

  public enum InstrumentationType {
    FUNCTION,
    BRANCH,
    BRANCH_DEFAULT;

    public static List<InstrumentationType> convertFromStringList(List<String> typesAsString) {
      return typesAsString.stream()
          .map(InstrumentationType::valueOf)
          .collect(Collectors.toList());
    }
  }

}
