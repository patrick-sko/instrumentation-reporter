/*
 * Copyright 2020 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.google;

import com.google.ProductionInstrumentationReporter.InstrumentationType;
import com.google.auto.value.AutoValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;


/**
 * A class that maintains all information about the production instrumentation results which will be
 * converted to a JSON.
 */
public class ProfilingReport {

  int totalReportsParsed;
  float percentOfFunctionsExecuted;
  float percentOfBranchesExecuted;

  List<FileProfilingResult> result;


  private ProfilingReport(int totalReportsParsed, List<FileProfilingResult> result) {
    this.totalReportsParsed = totalReportsParsed;
    this.result = result;

    calculateProfilingReportPercents();
  }

  private static float roundFloat2Decimals(float num) {
    return (Math.round(num * 10000) / (float) 100);
  }

  /**
   * This function takes the instrumentationMapping and reports sent by the instrumented production
   * code and creates a list of ProfilingResultsByFile with the aggregated information. It will
   * average the ProfilingData provided by allInstrumentationReports and also calculate a percentage
   * of how often a parameter is encounter.
   *
   * @param instrumentationMapping    The instrumentationMapping generated by the Production
   *                                  Instrumentation pass
   * @param allInstrumentationReports A list off all reports sent by the instrumented production
   *                                  code
   * @return A list of ProfilingResultsByFile where each element is the profiling result for a
   * different source file.
   */
  public static ProfilingReport createProfilingReport(
      InstrumentationMapping instrumentationMapping,
      List<Map<String, ProfilingData>> allInstrumentationReports) {

    List<FileProfilingResult> result = new ArrayList<>();

    // Iterate over all fileNames since that is what we are grouping by.
    for (String fileName : instrumentationMapping.fileNames) {

      // Get all instrumentation parameters where the source file is fileName.
      List<String> instrumentationPointsPerFile = instrumentationMapping.getAllMatchingValues((s) ->
          fileName.equals(instrumentationMapping.getFileName(s))
      );

      Map<String, List<ProfilingResult>> profilingDataPerFunction = new HashMap<>();

      for (String param : instrumentationPointsPerFile) {
        String functionName = instrumentationMapping.getFunctionName(param);

        float totalInstrumentationPointsExecuted = 0;
        int totalFrequency = 0;
        int instrumentationPointsCounter = 0;

        // For each param, iterate over allInstrumentationReports and check if param is present.
        // If it is, we will average the data, otherwise we will add to the average as if it is 0.
        for (Map<String, ProfilingData> instrumentationData : allInstrumentationReports) {
          ProfilingData profilingData = instrumentationData.get(param);
          instrumentationPointsCounter++;
          if (profilingData != null) {
            // if executed, add 1 to executionAverage, and 0 otherwise.
            totalFrequency += profilingData.frequency;
            totalInstrumentationPointsExecuted++;
          }
        }

        // Round the executionAverage to 2 decimal places for simplicity.
        float executed = roundFloat2Decimals(
            totalInstrumentationPointsExecuted / instrumentationPointsCounter);
        ProfilingData data = new ProfilingData(
            Math.round((float) totalFrequency / instrumentationPointsCounter));

        ProfilingResult profilingResult = ProfilingResult
            .create(instrumentationMapping, param, executed, data);

        if (profilingDataPerFunction.containsKey(functionName)) {
          profilingDataPerFunction.get(functionName).add(profilingResult);
        } else {
          profilingDataPerFunction
              .put(functionName, new ArrayList<>(Arrays.asList(profilingResult)));
        }
      }

      float percentOfFunctionsExecuted = calculatePercentOfInstrumentationExecuted(
          Arrays.asList(profilingDataPerFunction), (t) -> t.equals(InstrumentationType.FUNCTION));

      float percentOfBranchesExecuted = calculatePercentOfInstrumentationExecuted(
          Arrays.asList(profilingDataPerFunction), (t) -> t.equals(InstrumentationType.BRANCH) || t
              .equals(InstrumentationType.BRANCH_DEFAULT));

      FileProfilingResult fileProfilingResult = FileProfilingResult
          .create(fileName, percentOfFunctionsExecuted, percentOfBranchesExecuted,
              profilingDataPerFunction);

      result.add(fileProfilingResult);

    }

    return new ProfilingReport(allInstrumentationReports.size(), result);
  }

  /**
   * Iterates over the result property and calculates what percent out of all functions and branches
   * where executed to get aggregated instrumentation data.
   */
  private static float calculatePercentOfInstrumentationExecuted(
      List<Map<String, List<ProfilingResult>>> result,
      Predicate<InstrumentationType> instrumentationTypeCheck) {
    int totalInstrumentationPoints = 0;
    int totalInstrumentationPointsExecuted = 0;

    for (Map<String, List<ProfilingResult>> fileProfilingResult : result) {
      for (String key : fileProfilingResult.keySet()) {
        List<ProfilingResult> listOfProfilingResult = fileProfilingResult.get(key);
        for (ProfilingResult profilingResult : listOfProfilingResult) {
          if (instrumentationTypeCheck.test(profilingResult.type())) {
            totalInstrumentationPoints++;
            if (profilingResult.executed() != 0) {
              totalInstrumentationPointsExecuted++;
            }
          }
        }
      }
    }
    return roundFloat2Decimals(
        (float) totalInstrumentationPointsExecuted / totalInstrumentationPoints);
  }

  private void calculateProfilingReportPercents() {

    List<Map<String, List<ProfilingResult>>> listOfProfilingResultMaps = new ArrayList<>();
    for (FileProfilingResult fileProfilingResult : result) {
      listOfProfilingResultMaps.add(fileProfilingResult.profilingDataPerFunction());
    }

    this.percentOfFunctionsExecuted = calculatePercentOfInstrumentationExecuted(
        listOfProfilingResultMaps, (t) -> t.equals(InstrumentationType.FUNCTION));
    this.percentOfBranchesExecuted = calculatePercentOfInstrumentationExecuted(
        listOfProfilingResultMaps, (t) -> t.equals(InstrumentationType.BRANCH) || t
            .equals(InstrumentationType.BRANCH_DEFAULT));

  }

  /**
   * A class which groups profiling results by source file and contains a mapping of them to each
   * function which is present in that source file. Used also for Json conversion.
   */
  @AutoValue
  abstract static class FileProfilingResult {

    static FileProfilingResult create(String fileName, float percentOfFunctionsExecuted,
        float percentOfBranchesExecuted,
        Map<String, List<ProfilingResult>> profilingDataPerFunction) {
      return new AutoValue_ProfilingReport_FileProfilingResult(fileName, percentOfFunctionsExecuted,
          percentOfBranchesExecuted, profilingDataPerFunction);
    }

    abstract String fileName();

    abstract float percentOfFunctionsExecuted();

    abstract float percentOfBranchesExecuted();

    abstract Map<String, List<ProfilingResult>> profilingDataPerFunction();
  }

  /**
   * This class contains a detailed breakdown of each instrumentation point. For any encoded param,
   * this class will contain its details. The `executed` property will be a percent of total times
   * the instrumentation point was called across all provided instrumentation reports. i.e if
   * this.executed = 100, then every report would have this point present. Similarly, ProfilingData
   * takes the average of all ProfilingData's for this instrumentation point in all reports. Used
   * also for Json conversion.
   */
  @AutoValue
  abstract static class ProfilingResult {

    static ProfilingResult create(InstrumentationMapping instrumentationMapping, String param,
        float executed, ProfilingData data) {
      return new AutoValue_ProfilingReport_ProfilingResult(param,
          instrumentationMapping.getType(param), instrumentationMapping.getLineNo(param),
          instrumentationMapping.getColNo(param), executed, data);
    }

    abstract String param();

    abstract InstrumentationType type();

    abstract int lineNo();

    abstract int colNo();

    abstract float executed();

    abstract ProfilingData data();

  }


  /**
   * The instrumentation will send the report in a JSON format where the JSON is a dictionary of the
   * encoded params to an object of the data collected. Initially this will just be the frequency.
   */
  public static class ProfilingData {

    int frequency;

    public ProfilingData(int frequency) {
      this.frequency = frequency;
    }

  }

}
